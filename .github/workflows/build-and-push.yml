name: Separate Build and Push Stages

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Needed for GHCR

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to the Container registry (if pulling base images requires auth)
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/Akshaynipane/hello-world-app # Use your username here
        tags: |
          type=sha,format=long # e.g., v1.0.0-sha

    - name: Build Docker image ONLY (do not push yet)
      uses: docker/build-push-action@v6
      with:
        context: .
        push: false # Crucial: set to false to only build locally
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        # Cache is required so the next job can access it or it's built once

    # In a typical setup, the image is now cached on the runner's Docker daemon.
    # We rely on the implicit availability on the same runner/job scope.

env:
  CORTEX_API_KEY: ${{secrets.CORTEX_API_KEY}}
  CORTEX_API_KEY_ID: ${{secrets.CORTEX_API_KEY_ID}}
  CORTEX_API_URL: https://api-justruntime.xdr.us.paloaltonetworks.com
  
jobs:
  cortex-code-scan:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 22

    - name: Verify Node.js Version
      run: node -v

    - name: Download cortexcli
      run: |
        set -x
        crtx_resp=$(curl "${CORTEX_API_URL}/public_api/v1/unified-cli/releases/download-link?os=linux&architecture=amd64" \
          -H "x-xdr-auth-id: ${CORTEX_API_KEY_ID}" \
          -H "Authorization: ${CORTEX_API_KEY}")
        crtx_url=$(echo $crtx_resp | jq -r ".signed_url")
        curl -o cortexcli $crtx_url
        chmod +x cortexcli
        ./cortexcli --version

    - name: Run Cortex CLI Code Scan
      run: |
        ./cortexcli \
          --api-base-url "${CORTEX_API_URL}" \
          --api-key "${CORTEX_API_KEY}" \
          --api-key-id "${CORTEX_API_KEY_ID}" \
          code scan \
          --directory "${{github.workspace}}" \
          --repo-id "${{github.repository}}" \
          --branch "${{github.ref_name}}" \
          --source "GITHUB_ACTIONS" \
          --create-repo-if-missing

  push:
    needs: build # Ensures the build job runs first
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository # Needed to access the context of the build
      uses: actions/checkout@v4

    - name: Log in to the Container registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata again (to know what tags to push)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/Akshaynipane/hello-world-app # Use your username here
        tags: |
          type=sha,format=long

    - name: Build and Push the *same* Docker image (leverages cache from 'build' job)
      # Because both jobs run on fresh runners, we actually must rebuild AND push here.
      # Separating the jobs in this manner is inefficient in GitHub Actions.
      # The previous combined method is strongly recommended.
      # To truly separate them, you need a shared artifact store or a temporary registry.
      
      # Re-running the build-push-action is generally how you handle a separate 'push' job
      # as the 'build' job's environment is discarded after it finishes.
      uses: docker/build-push-action@v6
      with:
        context: .
        push: true # Crucial: set to true to push to registry
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
